# 트랜잭션 격리 수준(Transaction Isolation Level)

### 트랜잭션 격리 수준(Isolation level)

---

- 트랜잭션에서 일관성 없는 데이터를 허용하도록 하는 수준
- 동시에 여러 트랜잭션이 처리될 때, 트랜잭션끼리 얼마나 서로 고립되어 있는 지를 나타내는 것
- 특정 트랜잭션이 다른 트랜잭션에 변경한 데이터를 볼 수 있도록 허용할지 말 지를 결정하는 것

### Isolation level의 필요성

---

데이터 베이스는 ACID(원자성, 일관성, 격리,  영속성)

특징과 같이 트랜잭션이 독립적인 수행을 하도록 한다.

따라서 Locking을 통해, 트랜잭션이 DB를 다루는 동안 다른 트랜잭션이 관여하지 못하도록 막는 것이 필요하다.

아래는 추가 설명

```
하지만 무조건 Locking으로 동시에 수행되는 수많은 트랜잭션들을 순서대로 처리하는 방식으로 구현하게 되면 데이터베이스의 성능은 떨어지게 될 것이다.

그렇다고 해서, 성능을 높이기 위해 Locking의 범위를 줄인다면, 잘못된 값이 처리될 문제가 발생하게 된다.

- 따라서 최대한 효율적인 Locking 방법이 필요함!
```

### **Isolation level 종류**

---

1. **Read Uncommitted (레벨 0)**
    - SELECT 문장이 수행되는 동안 해당 데이터에 Shared Lock이 걸리지 않는 계층
    - READ UNCOMMITTED 격리수준에서는 어떤 트랜잭션의 변경내용이 COMMIT이나 ROLLBACK과 상관없이 다른 트랜잭션에서 보여진다.
    
    데이터베이스의 일관성을 유지하는 것이 불가능함
    
    ```
    A 트랜잭션에서 10번 사원의 나이를 27살에서 28살로 바꿈
    아직 커밋하지 않음
    B 트랜잭션에서 10번 사원의 나이를 조회함
    28살이 조회됨
    이를 더티 리드(Dirty Read)라고 한다
    
    A 트랜잭션에서 문제가 발생해 ROLLBACK함
    B 트랜잭션은 10번 사원이 여전히 28살이라고 생각하고 로직을 수행함
    ```
    
2. **Read Committed (레벨 1)**
    - SELECT 문장이 수행되는 동안 해당 데이터에 Shared Lock이 걸리는 계층
    
    트랜잭션이 수행되는 동안 다른 트랜잭션이 접근할 수 없어 대기하게 됨
    
    Commit이 이루어진 트랜잭션만 조회 가능
    
    대부분의 SQL 서버가 Default로 사용하는 Isolation Level임
    
    ```
    어떤 트랜잭션의 변경 내용이 COMMIT 되어야만 다른 트랜잭션에서 조회할 수 있다.
    오라클 DBMS에서 기본으로 사용하고 있고, 온라인 서비스에서 가장 많이 선택되는 격리수준이다.
    
    여기서는 B 트랜잭션에서 10번 사원의 나이를 조회해도 27살이 조회된다.(커밋되지 않았기 때문에)
    (이는 언두 영역에 저장된 데이터이다. MVCC 참조)
    A 트랜잭션에서 최종 커밋하면 B 트랜잭션에서 28살 이라는 값을 받아볼 수 있다.
    
    언뜻보면 정합성 문제가 해결된 것 처럼 보이지만, 여기서도 NON-REPETABLE READ 부정합 문제가 발생할 수 있다.
    
    B 트랜잭션에서 10번 사원의 나이를 조회
    27살이 조회됨
    A 트랜잭션에서 10번 사원의 나이를 27살에서 28살로 바꾸고 커밋
    B 트랜잭션에서 10번 사원의 나이를 다시 조회(변경되지 않은 이름이 조회됨)
    28살이 조회됨
    이는 하나의 트랜잭션내에서 똑같은 SELECT를 수행했을 경우 항상 같은 결과를 반환해야 한다는 REPEATABLE READ 정합성에 어긋나는 것이다.
    일반적인 웹 어플리케이션에서는 크게 문제되지 않지만, 작업이 금전적인 처리와 연결되어 있다면 문제가 발생할 수 있다.
    예를 들어 여러 트랜잭션에서 입금/출금 처리가 계속 진행되는 트랜잭션들이 있고
    오늘의 입금 총 합을 보여주는 트랜잭션이 있다고하면, 총합을 계산하는 SELECT 쿼리는 실행될 때 마다 다른 결과값을 가져올 것이다.
    
    이런 문제가 발생할 수 있기 떄문에 격리수준에 의해 실행되는 SQL 문장이 어떤 결과를 출력할 지 정확히 예측하고 있어야 한다.
    ```
    
3. **Repeatable Read (레벨 2)**
    - 트랜잭션이 완료될 때까지 SELECT 문장이 사용하는 모든 데이터에 Shared Lock이 걸리는 계층
    
    트랜잭션이 범위 내에서 조회한 데이터 내용이 항상 동일함을 보장함
    
    다른 사용자는 트랜잭션 영역에 해당되는 데이터에 대한 수정 불가능
    
    MySQL에서 Default로 사용하는 Isolation Level
    
    ```
    10번 트랜잭션이 500000번 사원을 조회
    12번 트랜잭션이 500000번 사원의 이름을 변경하고 커밋
    10번 트랜잭션이 500000번 사원을 다시 조회
    언두 영역에 백업된 데이터 반환
    즉, 간단하게 말해서 자신의 트랜잭션 번호보다 낮은 트랜잭션 번호에서 변경된(+커밋된) 것만 보게 되는 것이다.
    (모든 InnoDB의 트랜잭션은 고유한 트랜잭션 번호(순차적으로 증가하는)를 가지고 있으며,
    언두 영역에 백업된 모든 레코드는 변경을 발생시킨 트랜잭션의 번호가 포함되어 있다.)
    
    REPETABLE READ 격리수준에서는 트랜잭션이 시작된 시점의 데이터를 일관되게 보여주는 것을 보장해야 하기 때문에
    한 트랜잭션의 실행시간이 길어질수록 해당 시간만큼 계속 멀티 버전을 관리해야 하는 단점(?)이 있다.
    하지만 실제로 영향을 미칠 정도로 오래 지속되는 경우는 없어서… READ COMMITTED와 REPETABLE READ의 성능차이는 거의 없다고 한다.
    ```
    
4. **Serializable (레벨 3)**
    - 트랜잭션이 완료될 때까지 SELECT 문장이 사용하는 모든 데이터에 Shared Lock이 걸리는 계층
    
    완벽한 읽기 일관성 모드를 제공함
    
    다른 사용자는 트랜잭션 영역에 해당되는 데이터에 대한 수정 및 입력 불가능
    
    ```
    가장 단순하고 가장 엄격한 격리수준이다.
    InnoDB에서 기본적으로 순수한 SELECT 작업은 아무런 잠금을 걸지않고 동작하는데,
    격리수준이 SERIALIZABLE일 경우 읽기 작업에도 공유 잠금을 설정하게 되고, 이러면 동시에 다른 트랜잭션에서 이 레코드를 변경하지 못하게 된다.
    이러한 특성 때문에 동시처리 능력이 다른 격리수준보다 떨어지고, 성능저하가 발생하게 된다.
    ```
    

***선택 시 고려사항***

Isolation Level에 대한 조정은, 동시성과 데이터 무결성에 연관되어 있음

동시성을 증가시키면 데이터 무결성에 문제가 발생하고, 데이터 무결성을 유지하면 동시성이 떨어지게 됨

레벨을 높게 조정할 수록 발생하는 비용이 증가함

⇒ 동시성과  데이터 무결성 반비례 한다는 느낌

### **낮은 단계 Isolation Level을 활용할 때 발생하는 현상들**

- **Dirty Read**
    
    커밋되지 않은 수정 중인 데이터를 다른 트랜잭션에서 읽을 수 있도록 허용할 때 발생하는 현상
    
    어떤 트랜잭션에서 아직 실행이 끝나지 않은 다른 트랜잭션에 의한 변경 사항을 보게 되는 경우
    
    - 발생 Level: Read Uncommitted
    
- **Non-Repeatable Read**
    
    한 트랜잭션에서 같은 쿼리를 두 번 수행할 때 그 사이에 다른 트랜잭션 값을 수정 또는 삭제하면서 두 쿼리의 결과가 상이하게 나타나는 일관성이 깨진 현상
    
    - 발생 Level: Read Committed, Read Uncommitted

- **Phantom Read**
    
    한 트랜잭션 안에서 일정 범위의 레코드를 두 번 이상 읽었을 때, 첫 번째 쿼리에서 없던 레코드가 두 번째 쿼리에서 나타나는 현상
    
    트랜잭션 도중 새로운 레코드 삽입을 허용하기 때문에 나타나는 현상임
    
    - 발생 Level: Repeatable Read, Read Committed, Read Uncommitted
